---
title: "Utility to place PDF correctly on a 3D asset"
description: "Use two reference points on both the model and the PDF to place and scale the PDF in 3D space"
---

import { tutorials } from "@site/demo-snippets/index";

Normally PDF drawing are not scaled to the 3D geometry, correctly placing and scaling the PDF to fit the 3D geometry
by manipulaing scale, rotation and translations can be difficult. This tutorial will show how we can use the Novorender framework
to help place the PDF correctly. The tutorial is using a floorplan for a building as an example.

:::note
This tutorial is using database search multiple times, For more information on how to search and loading SceneData, see [Searching](./searching) first.
:::

### Fetch and draw PDF preview

PDF documents uploaded to Novorender will have a preview property that can be used to display the PDF as an image.
This image can be found by using database search and getting the metadata.

```typescript
const pdfScene = (await dataApi.loadScene(
  "bad260f94a5340b9b767ea2756392be4"
)) as SceneData;
if (pdfScene.db) {
  //Search for preview Property
  const iterator = pdfScene.db.search(
    {
      searchPattern: [{ property: "Novorender/Document/Preview", exact: true }],
    },
    undefined
  );
  let done = false;
  //Loop trough metadata and return the image, this will find the first PDF preview if there are several in the same scene
  while (!done) {
    const [result, _done] = await iterateAsync({ iterator, count: 10000 });
    done = _done;
    for (const ref of result) {
      const data = await ref.loadMetaData();
      for (const prop of data.properties) {
        if (prop[0] === "Novorender/Document/Preview") {
          return prop[1];
        }
      }
    }
    await sleep(1);
  }
}
return undefined;
```

The image can be drawn on a 2d canvas

```typescript
const img = new Image();
img.onload = function () {
  if (context) {
    context.drawImage(
      img,
      0,
      0,
      img.width,
      img.height,
      0,
      0,
      img.width,
      img.height
    );
  }
};
img.src = previewImage;
```

:::note
This tutorial is written without scaling or moving the image, if scaling and translations are used then these needs to be reveresed in
calculation section below
:::

### Fetch elevation from storey info

Storey elevations are normally stored in IFC files so this can be used to find the PDF elevation,
if not then manual input or other metadata is needed, the SceneData for this will need to be from the 3D model asset.

```typescript
const iterator = scene.search(
  {
    searchPattern: [
      { property: "IfcClass", value: "IfcBuildingStorey", exact: true },
    ],
  },
  undefined
);
...
      if (prop[0] === "Novorender/Elevation") {
        return Number(prop[1]);
      }
...
```

### Calculate rotation, scale and position

:::note
The PDF is scaled to fit one meter on the Y axis
:::

For these calculations we rely on two selected points from the PDF in pixels, that match two points on the 3D model.
To get the points from the PDF simply use the x and y position on the canvas, for points in the 3D model a top down
orthographic camera can be used with the pick() functionality on the webgl view. Elevation can be used to set a clipping plane,
for information on how to clip the model see [Clipping Volumes](./clipping_volumes), and for more information on
picking and drawing on top of a novorender model see [Draw measure object](./drawing2D).

:::note
To move the model coordinates to 2D Y must be discarded, Z will be flipped and used instead,
Elevation will be used to put it into 3D pace again
:::

```typescript
const modelPosA = vec2.fromValues(pickPositionA[0], pickPositionA[2] * -1);
const modelPosB = vec2.fromValues(pickPositionB[0], pickPositionB[2] * -1);
//Invert Y axis on the pixel positions on the pdf image
const pixelPosA = vec2.fromValues(pdfPosA[0], imgHeight.current - pdfPosA[1]);
const picelPosB = vec2.fromValues(pdfPosB[0], imgHeight.current - pdfPosB[1]);
const pixelLength = vec2.dist(pixelPosA, picelPosB);
const modelLength = vec2.dist(modelPosA, modelPosB);
const modelDir = vec2.sub(vec2.create(), modelPosB, modelPosA);
vec2.normalize(modelDir, modelDir);
const pixDir = vec2.sub(vec2.create(), pixelPosA, picelPosB);
vec2.normalize(pixDir, pixDir);
const scale = modelLength / pixelLength;

const angleAroundZ = vec2.dot(modelDir, pixDir);
const pdfToWorldScale = imgHeight.current * scale;
const translation = vec2.sub(
  vec2.create(),
  modelPosA,
  vec2.fromValues(pixelPosA[0] * scale, pixelPosA[1] * scale)
);
```

### Placing a preview of PDF in scene and update

Dynamic object will be used to place a preview of the PDF in model space, for more information on how dynamic objects are used
see [Dynamic Objects](./dynamic_objects). The dynamic model data can be found using the data api. Values found in the previous
section will be used to set scale, translation and rotation.

```typescript
const resource = await dataAPI.getResource("bad260f94a5340b9b767ea2756392be4");
const url = new URL(resource.gltf);
const asset = await api.loadAsset(url);
const instance = scene.createDynamicObject(asset);

instance.rotation = quat.fromEuler(quat.create(), 0, 0, angleAroundZ);
//flip back to coordinates where Y axis is up and adding elevation
instance.position = vec3.fromValues(
  translation[0],
  elevation,
  translation[1] * -1
);
instance.scale = pdfToWorldScale;
```

When it looks good this asset can be added to the scene.
